#!/usr/bin/env node
/**
 * Copies the Odhin report generated by Playwright into the legacy publish folder
 * so Jenkins can archive it. No-op if the report is missing.
 */
const fs = require('fs');
const path = require('path');

const source = resolveReportSourceFolder();
const targetRoot = resolveReportTargetRoot(source);
const target = path.join(targetRoot, 'odhin-report');
const sourceResolved = path.resolve(source);
const targetResolved = path.resolve(target);
const sourceAndTargetAreSame = sourceResolved === targetResolved;
const coverageRoot = path.resolve('reports', 'tests', 'coverage', 'api-playwright');
const coverageTarget = path.join(target, 'coverage');
const coverageSourceTarget = path.join(source, 'coverage');
const coverageLinkFlag = process.env.PW_ODHIN_LINK_COVERAGE === 'true';
const STDIO_MAX_LINES = parsePositiveInteger(process.env.PW_ODHIN_STDIO_MAX_LINES) ?? 140;
const STDIO_MAX_LINE_LENGTH = parsePositiveInteger(process.env.PW_ODHIN_STDIO_MAX_LINE_LENGTH) ?? 260;
const STDIO_MAX_CHARS = parsePositiveInteger(process.env.PW_ODHIN_STDIO_MAX_CHARS) ?? 18000;
const API_LEADERBOARD_LIMIT = parsePositiveInteger(process.env.PW_ODHIN_API_LEADERBOARD_LIMIT) ?? 20;
const NODE_API_SCAN_MAX_DIRS = parsePositiveInteger(process.env.PW_ODHIN_NODE_API_SCAN_MAX_DIRS) ?? 2000;
const NODE_API_SCAN_MAX_DEPTH = parsePositiveInteger(process.env.PW_ODHIN_NODE_API_SCAN_MAX_DEPTH) ?? 8;
const NODE_API_SCAN_SKIP_DIRS = new Set(['.git', 'node_modules', 'coverage', 'playwright-report', 'odhin-report', 'lcov-report']);

try {
  if (!fs.existsSync(source)) {
    process.exit(0);
  }

  if (!sourceAndTargetAreSame) {
    fs.mkdirSync(targetRoot, { recursive: true });
    // Best-effort clean copy
    fs.rmSync(target, { recursive: true, force: true });
    copyReportArtifacts(source, target, { skipCoverage: coverageLinkFlag });
  }

  const reportFolders = sourceAndTargetAreSame ? [source] : [source, target];
  const apiReport = collectApiEndpointsFromLogs(resolveNodeApiLogRoots(), [source]);

  reportFolders.forEach((reportFolder) => compactVerboseStdIo(reportFolder));
  reportFolders.forEach((reportFolder) => injectNodeApiTab(reportFolder, apiReport));

  const coverageRootIndex = coverageLinkFlag && fs.existsSync(coverageRoot) ? findCoverageIndex(coverageRoot) : undefined;
  if (coverageRootIndex) {
    if (sourceAndTargetAreSame) {
      copyCoverageArtifacts(coverageRoot, coverageSourceTarget);

      const sourceCoverageIndex = renameCoverageIndex(findCoverageIndex(coverageSourceTarget));
      const sourceCoverageSummary = loadCoverageSummary(coverageSourceTarget);

      if (sourceCoverageIndex) {
        injectCoverageLink(source, path.relative(source, sourceCoverageIndex), sourceCoverageSummary);
        injectCoverageTab(source, path.relative(source, sourceCoverageIndex));
      } else {
        console.warn('copy-odhin-report: source coverage index not found; skipping source coverage injection.');
      }
    } else {
      // Keep coverage artifacts and tabs available in both locations:
      // - source (playwright-api) for local direct opens
      // - target (api_functional) for CI/Jenkins artifacts
      copyCoverageArtifacts(coverageRoot, coverageSourceTarget);
      copyCoverageArtifacts(coverageRoot, coverageTarget);

      const sourceCoverageIndex = renameCoverageIndex(findCoverageIndex(coverageSourceTarget));
      const targetCoverageIndex = renameCoverageIndex(findCoverageIndex(coverageTarget));

      const sourceCoverageSummary = loadCoverageSummary(coverageSourceTarget);
      const targetCoverageSummary = loadCoverageSummary(coverageTarget);

      if (sourceCoverageIndex) {
        injectCoverageLink(source, path.relative(source, sourceCoverageIndex), sourceCoverageSummary);
        injectCoverageTab(source, path.relative(source, sourceCoverageIndex));
      } else {
        console.warn('copy-odhin-report: source coverage index not found; skipping source coverage injection.');
      }

      if (targetCoverageIndex) {
        injectCoverageLink(target, path.relative(target, targetCoverageIndex), targetCoverageSummary);
        injectCoverageTab(target, path.relative(target, targetCoverageIndex));
      } else {
        console.warn('copy-odhin-report: target coverage index not found; skipping target coverage injection.');
      }
    }
  }
} catch (error) {
  console.warn(`copy-odhin-report: ${error.message}`);
  process.exit(0); // do not fail the build if copy fails
}

function copyCoverageArtifacts(sourceDir, destinationDir) {
  fs.rmSync(destinationDir, { recursive: true, force: true });
  fs.cpSync(sourceDir, destinationDir, {
    recursive: true,
    force: true,
    // Raw V8 payloads are large and not needed for embedded HTML coverage viewing.
    filter: (srcPath) => {
      const relativePath = path.relative(sourceDir, srcPath);
      if (!relativePath || relativePath === '.') {
        return true;
      }
      return relativePath !== 'tmp' && !relativePath.startsWith(`tmp${path.sep}`);
    },
  });
}

function copyReportArtifacts(sourceDir, destinationDir, { skipCoverage = false } = {}) {
  fs.cpSync(sourceDir, destinationDir, {
    recursive: true,
    force: true,
    filter: (srcPath) => {
      if (!skipCoverage) {
        return true;
      }
      const relativePath = path.relative(sourceDir, srcPath);
      if (!relativePath || relativePath === '.') {
        return true;
      }
      return relativePath !== 'coverage' && !relativePath.startsWith(`coverage${path.sep}`);
    },
  });
}

function findCoverageIndex(rootDir) {
  const candidates = [
    // Preferred: folder-scoped API index
    path.join(rootDir, 'rpx-xui-webapp', 'playwright_tests_new', 'api', 'index.html'),
    path.join(rootDir, 'rpx-xui-webapp', 'playwright_tests_new', 'api', 'api-coverage-report.html'),
    // c8 layout variant under lcov-report
    path.join(rootDir, 'lcov-report', 'rpx-xui-webapp', 'playwright_tests_new', 'api', 'index.html'),
    path.join(rootDir, 'lcov-report', 'rpx-xui-webapp', 'playwright_tests_new', 'api', 'api-coverage-report.html'),
    // Root-level fallbacks
    path.join(rootDir, 'index.html'),
    path.join(rootDir, 'api-coverage-report.html'),
    path.join(rootDir, 'lcov-report', 'index.html'),
  ];
  return candidates.find((candidate) => fs.existsSync(candidate));
}

function resolveReportSourceFolder() {
  if (process.env.PLAYWRIGHT_REPORT_FOLDER) {
    return path.resolve(process.env.PLAYWRIGHT_REPORT_FOLDER);
  }

  const defaultFolder = path.resolve(path.join('functional-output', 'tests', 'playwright-e2e', 'odhin-report'));
  const candidates = [
    defaultFolder,
    path.resolve(path.join('functional-output', 'tests', 'playwright-api', 'odhin-report')),
    path.resolve(path.join('functional-output', 'tests', 'playwright-api-journeys', 'odhin-report')),
    path.resolve(path.join('functional-output', 'tests', 'playwright-integration', 'odhin-report')),
    path.resolve(path.join('functional-output', 'tests', 'playwright', 'odhin-report')),
    path.resolve(path.join('test-results', 'odhin-report')),
  ];

  const existing = candidates
    .filter((folder) => fs.existsSync(folder))
    .map((folder) => ({
      folder,
      freshness: getReportFolderFreshness(folder),
    }))
    .sort((left, right) => right.freshness - left.freshness);

  return existing.length > 0 ? existing[0].folder : defaultFolder;
}

function resolveReportTargetRoot(sourceFolder) {
  if (process.env.PLAYWRIGHT_REPORT_TARGET_ROOT) {
    return path.resolve(process.env.PLAYWRIGHT_REPORT_TARGET_ROOT);
  }

  const normalized = sourceFolder.replace(/\\/g, '/');
  if (normalized.includes('/functional-output/tests/playwright-api-journeys/odhin-report')) {
    return path.resolve(path.join('functional-output', 'tests', 'api_functional_journeys'));
  }
  if (normalized.includes('/functional-output/tests/playwright-api/odhin-report')) {
    return path.resolve(path.join('functional-output', 'tests', 'api_functional'));
  }

  return path.dirname(sourceFolder);
}

function getReportFolderFreshness(folder) {
  try {
    const htmlFiles = fs
      .readdirSync(folder)
      .filter((name) => name.toLowerCase().endsWith('.html'))
      .map((name) => path.join(folder, name));
    if (htmlFiles.length === 0) {
      return fs.statSync(folder).mtimeMs;
    }
    return htmlFiles.map((file) => fs.statSync(file).mtimeMs).sort((left, right) => right - left)[0];
  } catch {
    return 0;
  }
}

function renameCoverageIndex(indexPath) {
  if (!indexPath) return undefined;
  const newPath = path.join(path.dirname(indexPath), 'api-coverage-report.html');
  try {
    fs.renameSync(indexPath, newPath);
    return newPath;
  } catch {
    return indexPath;
  }
}

function loadCoverageSummary(rootDir) {
  const summaryPath = path.join(rootDir, 'coverage-summary.json');
  if (!fs.existsSync(summaryPath)) {
    return undefined;
  }
  try {
    const json = JSON.parse(fs.readFileSync(summaryPath, 'utf8'));
    return json?.total;
  } catch (err) {
    console.warn(`copy-odhin-report: unable to parse coverage summary: ${err.message}`);
    return undefined;
  }
}

function injectCoverageLink(reportFolder, relativeCoveragePath, totals) {
  const files = fs.readdirSync(reportFolder).filter((f) => f.toLowerCase().endsWith('.html'));
  const rows = totals
    ? [
        ['Lines', totals.lines],
        ['Functions', totals.functions],
        ['Branches', totals.branches],
        ['Statements', totals.statements],
      ]
        .map(([label, data]) => {
          const pct = typeof data?.pct === 'number' ? data.pct.toFixed(2) : 'n/a';
          const covered = data?.covered ?? 0;
          const total = data?.total ?? 0;
          return `<tr>
      <td class="fs-6 text-secondary-emphasis text-start summary-row-left-column">${label}</td>
      <td class="text-secondary-emphasis">${pct}%</td>
      <td class="text-secondary-emphasis">${covered}</td>
      <td class="text-secondary-emphasis">${total}</td>
    </tr>`;
        })
        .join('\n')
    : '';

  const block = `
          <div class="row ms-3 me-3">
            <div class="col-12">
              <div class="mt-3 mb-3 odhin-thin-border dashboard-block">
                <div class="info-box-header">Coverage</div>
                <p class="text-secondary-emphasis small mb-2 ps-2">
                  Scope: totals from coverage-summary.json (all instrumented files in this run). Embedded HTML report may be folder-specific.
                </p>
                <div class="odhin-table">
                  <div class="table-responsive">
                    <table class="table table-sm mb-0 testcase-run-info-table">
                      <thead>
                        <tr>
                          <th class="odhin-text-3">Metric</th>
                          <th class="odhin-text-3">Percent</th>
                          <th class="odhin-text-3">Covered</th>
                          <th class="odhin-text-3">Total</th>
                        </tr>
                      </thead>
                      <tbody>
                        ${rows || '<tr><td colspan="4" class="text-secondary-emphasis">Summary unavailable</td></tr>'}
                      </tbody>
                    </table>
                  </div>
                </div>
              </div>
            </div>
          </div>`;
  files.forEach((file) => {
    const fullPath = path.join(reportFolder, file);
    try {
      let html = fs.readFileSync(fullPath, 'utf8');
      if (!html.includes('id="TabDashboard"')) {
        return;
      }
      // Remove any previously injected coverage block
      html = html.replace(
        /<div class="row ms-3 me-3">\s*<div class="col-12[^>]*>\s*<div class="mt-3 mb-3 odhin-thin-border dashboard-block">\s*<div class="info-box-header">Coverage[\s\S]*?<\/div>\s*<\/div>\s*<\/div>\s*<\/div>/m,
        ''
      );

      const tabDashPattern = /(<div[^>]+id="TabDashboard"[\s\S]*?)(<\/div>\s*<div[^>]+id="TabTests")/m;
      if (tabDashPattern.test(html)) {
        html = html.replace(tabDashPattern, (_m, before, after) => `${before}\n${block}\n</div>\n${after}`);
      }
      fs.writeFileSync(fullPath, html, 'utf8');
    } catch {
      // ignore
    }
  });
}

function injectCoverageTab(reportFolder, relativeCoveragePath) {
  const files = fs.readdirSync(reportFolder).filter((f) => f.toLowerCase().endsWith('.html'));
  const tabButton = `
							<button
								class="main-tablinks"
								onclick="openMainTab(event, 'TabCoverage')"
							>
								Coverage
							</button>`;
  const tabPane = `
<div id="TabCoverage" style="display: none" class="main-tabcontent">
  <div class="container-fluid text-center mt-3 mb-5">
    <div class="row ms-3 me-3">
      <div class="col-12">
        <div class="mt-3 mb-3 odhin-thin-border dashboard-block">
          <div class="info-box-header">Coverage report</div>
          <p class="text-secondary-emphasis small mb-3 ps-2">
            Source: ${relativeCoveragePath} (may be folder-specific).
          </p>
          <div class="odhin-table-no-scroll">
            <div class="table-responsive">
              <iframe src="${relativeCoveragePath}" style="width:100%;min-height:900px;border:0;"></iframe>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>`;

  files.forEach((file) => {
    const fullPath = path.join(reportFolder, file);
    try {
      let html = fs.readFileSync(fullPath, 'utf8');
      if (html.includes('id="TabCoverage"')) {
        return;
      }
      const tabBlock = /(<div class="tab">[\s\S]*?)(<\/div>\s*<\/div>\s*<\/div>\s*<\/div>)/m;
      if (tabBlock.test(html)) {
        html = html.replace(tabBlock, `$1${tabButton}$2`);
      }
      html = html.replace('</body>', `${tabPane}\n</body>`);
      fs.writeFileSync(fullPath, html, 'utf8');
    } catch {
      // ignore
    }
  });
}

function resolveNodeApiLogRoots() {
  const roots = new Set();
  const envRoots = [process.env.PW_NODE_API_LOG_ROOT, process.env.PLAYWRIGHT_OUTPUT_DIR, process.env.PLAYWRIGHT_TEST_OUTPUT_DIR];
  envRoots.filter(Boolean).forEach((root) => roots.add(path.resolve(root)));
  roots.add(path.resolve('test-results'));
  return Array.from(roots).filter((root) => fs.existsSync(root));
}

function compactVerboseStdIo(reportFolder) {
  const files = fs.readdirSync(reportFolder).filter((f) => f.toLowerCase().endsWith('.html'));
  files.forEach((file) => {
    const fullPath = path.join(reportFolder, file);
    try {
      const html = fs.readFileSync(fullPath, 'utf8');
      const compacted = compactStdIoHtml(html);
      if (compacted !== html) {
        fs.writeFileSync(fullPath, compacted, 'utf8');
      }
    } catch {
      // ignore
    }
  });
}

function compactStdIoHtml(html) {
  const compactedLogs = html.replace(
    /(<pre class="pre"><code>)([\s\S]*?)(<\/code><\/pre>)/g,
    (_match, openTag, logText, closeTag) => {
      return `${openTag}${compactStdIoText(logText)}${closeTag}`;
    }
  );

  const compactedDownloads = compactedLogs.replace(
    /<a([^>]*download="(?:stdout|stderr)\.txt"[^>]*)href="data:text\/html,[^"]*"([^>]*)>/gi,
    (_match, beforeHref, afterHref) =>
      `<a${beforeHref}href="data:text/plain,${encodeURIComponent(
        'Output trimmed in Odhin report. Use Playwright raw artifacts for full stdout/stderr.'
      )}"${afterHref}>`
  );

  return compactedDownloads;
}

function compactStdIoText(rawText) {
  if (typeof rawText !== 'string' || rawText.length === 0) {
    return rawText;
  }

  const redacted = redactSecrets(rawText.replace(/\r/g, ''));
  const inputLines = redacted.split('\n');
  const compactedLines = [];

  const lineCap = Math.min(inputLines.length, STDIO_MAX_LINES);
  for (let index = 0; index < lineCap; index += 1) {
    compactedLines.push(truncateLine(inputLines[index], STDIO_MAX_LINE_LENGTH));
  }

  if (inputLines.length > lineCap) {
    compactedLines.push(`[... ${inputLines.length - lineCap} additional log lines omitted ...]`);
  }

  let compacted = compactedLines.join('\n');
  if (compacted.length > STDIO_MAX_CHARS) {
    compacted = `${compacted.slice(0, STDIO_MAX_CHARS)}\n[... additional log content truncated ...]`;
  }

  return compacted;
}

function redactSecrets(value) {
  return value
    .replace(/(cookie:\s*).*/gi, '$1[REDACTED]')
    .replace(/('cookie'\s*:\s*')[^']*(')/gi, '$1[REDACTED]$2')
    .replace(/("cookie"\s*:\s*")[^"]*(")/gi, '$1[REDACTED]$2')
    .replace(/(XSRF-TOKEN=)[^;\s'"]+/gi, '$1[REDACTED]')
    .replace(/(__auth__=)[^;\s'"]+/gi, '$1[REDACTED]')
    .replace(/(Authorization:\s*Bearer\s+)[A-Za-z0-9._-]+/gi, '$1[REDACTED]')
    .replace(/\beyJ[A-Za-z0-9_-]{20,}\.[A-Za-z0-9_-]{20,}\.[A-Za-z0-9_-]{20,}\b/g, '[REDACTED_JWT]');
}

function truncateLine(value, maxLength) {
  if (value.length <= maxLength) {
    return value;
  }
  return `${value.slice(0, maxLength)} ...[truncated]`;
}

function collectApiEndpointsFromLogs(roots, reportFolders = []) {
  const slowThresholdMs = parsePositiveInteger(process.env.API_SLOW_THRESHOLD_MS) ?? 5000;
  const nodeApiCollection = collectApiEventsFromNodeApiLogs(roots);
  let dataSource = 'node-api-calls';
  let reportFilesScanned = 0;
  let events = nodeApiCollection.events;

  if (nodeApiCollection.logFiles === 0) {
    dataSource = 'runtime-logs';
    const reportEvents = collectApiEventsFromReportLogs(reportFolders, slowThresholdMs);
    reportFilesScanned = reportEvents.reportFilesScanned;
    events = reportEvents.events;
  }

  return buildApiEndpointReport(events, {
    dataSource,
    logFiles: nodeApiCollection.logFiles,
    reportFilesScanned,
    slowThresholdMs,
  });
}

function collectApiEventsFromNodeApiLogs(roots) {
  const events = [];
  let logFiles = 0;

  (roots || []).forEach((rootDir) => {
    if (!fs.existsSync(rootDir)) {
      return;
    }

    const files = findNodeApiCallFiles(rootDir);
    files.forEach((file) => {
      logFiles += 1;
      events.push(...loadApiEventsFromNodeApiFile(file));
    });
  });

  return { events, logFiles };
}

function loadApiEventsFromNodeApiFile(filePath) {
  try {
    const raw = fs.readFileSync(filePath, 'utf8');
    const entries = JSON.parse(raw);
    if (!Array.isArray(entries)) {
      return [];
    }
    return entries.map((entry) => buildApiEventFromNodeApiEntry(entry));
  } catch {
    // ignore malformed attachments
    return [];
  }
}

function buildApiEventFromNodeApiEntry(entry) {
  const endpoint = extractEndpointFromLog(entry);
  const status =
    typeof entry?.status === 'number' && Number.isFinite(entry.status) ? Math.trunc(entry.status) : undefined;
  const durationMs =
    typeof entry?.durationMs === 'number' && Number.isFinite(entry.durationMs) ? Math.round(entry.durationMs) : undefined;
  const errorMessage = `${entry?.error ?? ''} ${entry?.errorMessage ?? ''}`.trim();
  const timedOut = isTimeoutError(errorMessage);
  const hasError = Boolean(errorMessage);
  const failed = timedOut || hasError || status === 0 || (typeof status === 'number' && status >= 400) || entry?.ok === false;
  return {
    method: entry?.method,
    endpoint,
    status,
    durationMs,
    timedOut,
    hasError,
    failed,
  };
}

function buildApiEndpointReport(events, metadata) {
  const state = {
    endpointCounts: new Map(),
    failedEndpointCounts: new Map(),
    slowEndpointCounts: new Map(),
    totalCalls: 0,
    totalFailedCalls: 0,
    totalTimeoutCalls: 0,
    totalSlowCalls: 0,
  };

  events.forEach((event) => {
    recordApiEvent(state, event, metadata.slowThresholdMs);
  });

  return {
    dataSource: metadata.dataSource,
    logFiles: metadata.logFiles,
    reportFilesScanned: metadata.reportFilesScanned,
    slowThresholdMs: metadata.slowThresholdMs,
    totalCalls: state.totalCalls,
    uniqueEndpoints: state.endpointCounts.size,
    endpoints: sortEndpointInventory(state.endpointCounts),
    totalFailedCalls: state.totalFailedCalls,
    totalTimeoutCalls: state.totalTimeoutCalls,
    failedEndpoints: sortFailedEndpointInventory(state.failedEndpointCounts),
    totalSlowCalls: state.totalSlowCalls,
    slowEndpoints: sortSlowEndpointInventory(state.slowEndpointCounts),
  };
}

function recordApiEvent(state, event, slowThresholdMs) {
  const { method, endpoint, status, durationMs, timedOut = false, hasError = false, failed, slow } = event;
  if (!endpoint) {
    return;
  }

  const normalizedMethod = normalizeMethod(method);
  const key = `${normalizedMethod} ${endpoint}`;
  const failedOutcome =
    typeof failed === 'boolean'
      ? failed
      : timedOut || hasError || status === 0 || (typeof status === 'number' && status >= 400);
  const slowOutcome = typeof slow === 'boolean' ? slow : typeof durationMs === 'number' && durationMs > slowThresholdMs;
  const slowDurationMs = typeof durationMs === 'number' ? durationMs : slowThresholdMs;

  state.totalCalls += 1;
  if (!state.endpointCounts.has(key)) {
    state.endpointCounts.set(key, { method: normalizedMethod, endpoint, hits: 0 });
  }
  state.endpointCounts.get(key).hits += 1;

  if (failedOutcome) {
    state.totalFailedCalls += 1;
    if (timedOut) {
      state.totalTimeoutCalls += 1;
    }
    if (!state.failedEndpointCounts.has(key)) {
      state.failedEndpointCounts.set(key, { method: normalizedMethod, endpoint, hits: 0, timeoutHits: 0, statusBreakdown: {} });
    }
    const failedRecord = state.failedEndpointCounts.get(key);
    failedRecord.hits += 1;
    if (timedOut) {
      failedRecord.timeoutHits += 1;
    }
    const failedStatusKey = resolveStatusKey(status, timedOut, hasError || failedOutcome);
    failedRecord.statusBreakdown[failedStatusKey] = (failedRecord.statusBreakdown[failedStatusKey] ?? 0) + 1;
  }

  if (slowOutcome) {
    state.totalSlowCalls += 1;
    if (!state.slowEndpointCounts.has(key)) {
      state.slowEndpointCounts.set(key, { method: normalizedMethod, endpoint, hits: 0, durations: [], statusBreakdown: {} });
    }
    const slowRecord = state.slowEndpointCounts.get(key);
    slowRecord.hits += 1;
    slowRecord.durations.push(Math.round(slowDurationMs));
    const slowStatusKey = resolveStatusKey(status, timedOut, hasError || failedOutcome);
    slowRecord.statusBreakdown[slowStatusKey] = (slowRecord.statusBreakdown[slowStatusKey] ?? 0) + 1;
  }
}

function sortEndpointInventory(endpointCounts) {
  return Array.from(endpointCounts.values()).sort((left, right) => {
    if (right.hits !== left.hits) {
      return right.hits - left.hits;
    }
    if (left.method !== right.method) {
      return left.method.localeCompare(right.method);
    }
    return left.endpoint.localeCompare(right.endpoint);
  });
}

function sortFailedEndpointInventory(failedEndpointCounts) {
  return Array.from(failedEndpointCounts.values()).sort((left, right) => {
    if (right.hits !== left.hits) {
      return right.hits - left.hits;
    }
    if (right.timeoutHits !== left.timeoutHits) {
      return right.timeoutHits - left.timeoutHits;
    }
    if (left.method !== right.method) {
      return left.method.localeCompare(right.method);
    }
    return left.endpoint.localeCompare(right.endpoint);
  });
}

function sortSlowEndpointInventory(slowEndpointCounts) {
  return Array.from(slowEndpointCounts.values())
    .map((entry) => {
      const sortedDurations = [...entry.durations].sort((left, right) => left - right);
      const maxMs = sortedDurations.length > 0 ? sortedDurations[sortedDurations.length - 1] : 0;
      const sumMs = sortedDurations.reduce((sum, duration) => sum + duration, 0);
      const avgMs = sortedDurations.length > 0 ? round(sumMs / sortedDurations.length) : 0;
      return {
        method: entry.method,
        endpoint: entry.endpoint,
        hits: entry.hits,
        avgDurationMs: avgMs,
        p95DurationMs: percentile(sortedDurations, 95),
        maxDurationMs: maxMs,
        statusBreakdown: entry.statusBreakdown,
      };
    })
    .sort((left, right) => {
      if (right.p95DurationMs !== left.p95DurationMs) {
        return right.p95DurationMs - left.p95DurationMs;
      }
      if (right.maxDurationMs !== left.maxDurationMs) {
        return right.maxDurationMs - left.maxDurationMs;
      }
      if (right.hits !== left.hits) {
        return right.hits - left.hits;
      }
      if (left.method !== right.method) {
        return left.method.localeCompare(right.method);
      }
      return left.endpoint.localeCompare(right.endpoint);
    });
}

function collectApiEventsFromReportLogs(reportFolders, slowThresholdMs) {
  const events = [];
  const folders = Array.from(new Set((reportFolders || []).map((folder) => path.resolve(folder))));
  let reportFilesScanned = 0;

  folders.forEach((folder) => {
    if (!fs.existsSync(folder)) {
      return;
    }
    const files = fs.readdirSync(folder).filter((file) => file.toLowerCase().endsWith('.html'));
    files.forEach((file) => {
      reportFilesScanned += 1;
      try {
        const html = fs.readFileSync(path.join(folder, file), 'utf8');
        const codeBlocks = html.matchAll(/<pre class="pre"><code>([\s\S]*?)<\/code><\/pre>/g);
        for (const block of codeBlocks) {
          const logText = stripAnsi(decodeHtmlEntities(block[1]));
          const parsedEvents = parseApiEventsFromLogText(logText, slowThresholdMs);
          parsedEvents.forEach((event) => {
            if (!event.endpoint) {
              return;
            }
            const eventKey = `${event.timestamp ?? ''}|${event.method}|${event.endpoint}|${event.status ?? ''}|${event.durationMs ?? ''}|${
              event.failed ? '1' : '0'
            }|${event.slow ? '1' : '0'}|${event.timedOut ? '1' : '0'}`;
            if (event.timestamp && events.some((existing) => buildApiEventKey(existing) === eventKey)) {
              return;
            }
            events.push(event);
          });
        }
      } catch {
        // ignore malformed html files
      }
    });
  });

  return { events, reportFilesScanned };
}

function parseApiEventsFromLogText(logText, slowThresholdMs) {
  const failureEvents = parseStructuredApiEvents(logText, 'DOWNSTREAM_API_FAILURE', { failed: true }, slowThresholdMs);
  const slowEvents = parseStructuredApiEvents(logText, 'Slow API response detected', { slow: true }, slowThresholdMs);
  const inlineEvents = [];

  const inlineStatusRegex = /\b(GET|POST|PUT|PATCH|DELETE)\s+(https?:\/\/[^\s]+)\s*->\s*(\d{3})/gi;
  let inlineMatch = inlineStatusRegex.exec(logText);
  while (inlineMatch) {
    const timestamp = extractIsoTimestamp(
      logText.slice(Math.max(0, inlineMatch.index - 80), inlineMatch.index + inlineMatch[0].length)
    );
    const method = normalizeMethod(inlineMatch[1]);
    const endpoint = extractEndpointFromRawUrl(inlineMatch[2]);
    const status = Number.parseInt(inlineMatch[3], 10);
    const timedOut = status === 408 || status === 504;
    const failed = status >= 400 || timedOut;
    inlineEvents.push({
      method,
      endpoint,
      status,
      timedOut,
      hasError: failed,
      failed,
      slow: false,
      timestamp,
    });
    inlineMatch = inlineStatusRegex.exec(logText);
  }

  return [...failureEvents, ...slowEvents, ...inlineEvents];
}

function parseStructuredApiEvents(logText, marker, defaults, slowThresholdMs) {
  const events = [];
  const regex = new RegExp(`${escapeRegex(marker)}[\\s\\S]*?\\{([\\s\\S]*?)\\n\\}`, 'g');
  let match = regex.exec(logText);
  while (match) {
    const timestamp = extractIsoTimestamp(logText.slice(Math.max(0, match.index - 80), match.index + marker.length));
    const body = match[1];
    const urlMatch = body.match(/"url"\s*:\s*"([^"]+)"/i);
    if (!urlMatch) {
      match = regex.exec(logText);
      continue;
    }

    const methodMatch = body.match(/"method"\s*:\s*"([A-Za-z]+)"/i);
    const statusMatch = body.match(/"status"\s*:\s*(\d{3})/i);
    const durationMsMatch = body.match(/"durationMs"\s*:\s*([0-9]+(?:\.[0-9]+)?)/i);
    const durationTextMatch = body.match(/"duration"\s*:\s*"([^"]+)"/i);

    const method = normalizeMethod(methodMatch ? methodMatch[1] : 'UNKNOWN');
    const endpoint = extractEndpointFromRawUrl(urlMatch[1]);
    const status = statusMatch ? Number.parseInt(statusMatch[1], 10) : undefined;
    const durationMs = durationMsMatch
      ? Math.round(Number.parseFloat(durationMsMatch[1]))
      : parseDurationMs(durationTextMatch?.[1]);
    const timedOut = status === 408 || status === 504 || isTimeoutError(body);
    const failed = defaults.failed === true || timedOut || (typeof status === 'number' && status >= 400);
    const slow = defaults.slow === true || (typeof durationMs === 'number' && durationMs > slowThresholdMs);

    events.push({
      method,
      endpoint,
      status,
      durationMs,
      timedOut,
      hasError: failed || timedOut,
      failed,
      slow,
      timestamp,
    });
    match = regex.exec(logText);
  }

  return events;
}

function parseDurationMs(durationText) {
  if (typeof durationText !== 'string' || durationText.trim().length === 0) {
    return undefined;
  }

  const trimmed = durationText.trim();
  if (/unknown/i.test(trimmed)) {
    return undefined;
  }

  const msMatch = trimmed.match(/([0-9]+(?:\.[0-9]+)?)\s*ms/i);
  if (msMatch) {
    return Math.round(Number.parseFloat(msMatch[1]));
  }

  const secondsMatch = trimmed.match(/([0-9]+(?:\.[0-9]+)?)\s*s(ec(onds?)?)?/i);
  if (secondsMatch) {
    return Math.round(Number.parseFloat(secondsMatch[1]) * 1000);
  }

  const numeric = Number.parseFloat(trimmed);
  if (Number.isFinite(numeric)) {
    return Math.round(numeric);
  }

  return undefined;
}

function extractIsoTimestamp(rawText) {
  if (typeof rawText !== 'string') {
    return undefined;
  }
  const match = rawText.match(/\b\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:\.\d+)?Z\b/);
  return match ? match[0] : undefined;
}

function buildApiEventKey(event) {
  return `${event.timestamp ?? ''}|${event.method ?? ''}|${event.endpoint ?? ''}|${event.status ?? ''}|${
    event.durationMs ?? ''
  }|${event.failed ? '1' : '0'}|${event.slow ? '1' : '0'}|${event.timedOut ? '1' : '0'}`;
}

function stripAnsi(value) {
  if (typeof value !== 'string') {
    return '';
  }
  return value.replace(/\u001b\[[0-?]*[ -/]*[@-~]/g, '');
}

function decodeHtmlEntities(value) {
  return value
    .replace(/&gt;/g, '>')
    .replace(/&lt;/g, '<')
    .replace(/&quot;/g, '"')
    .replace(/&#39;/g, "'")
    .replace(/&amp;/g, '&');
}

function escapeRegex(value) {
  return value.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

function extractEndpointFromLog(entry) {
  const rawUrl = entry?.url;
  return extractEndpointFromRawUrl(rawUrl);
}

function extractEndpointFromRawUrl(rawUrl) {
  if (typeof rawUrl !== 'string' || !rawUrl) {
    return undefined;
  }
  let endpoint = rawUrl;
  if (/^https?:\/\//i.test(rawUrl)) {
    try {
      const parsed = new URL(rawUrl);
      endpoint = `${parsed.pathname}${parsed.search}`;
    } catch {
      endpoint = rawUrl;
    }
  }
  endpoint = endpoint.replace(/^\/+/, '');
  return normalizeEndpoint(endpoint);
}

function normalizeMethod(method) {
  if (typeof method !== 'string' || !method.trim()) {
    return 'UNKNOWN';
  }
  return method.toUpperCase();
}

function normalizeEndpoint(endpoint) {
  const uuidRe = /\b[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}\b/gi;
  const hexRe = /\b[0-9a-f]{32,}\b/gi;
  const caseIdRe = /\b\d{16}\b/g;
  const longNumberRe = /\b\d{6,}\b/g;
  return endpoint
    .replace(uuidRe, '${uuid}')
    .replace(hexRe, '${id}')
    .replace(caseIdRe, '${caseId}')
    .replace(longNumberRe, '${id}');
}

function resolveStatusKey(status, timedOut, hasError) {
  if (timedOut) {
    return 'timeout';
  }
  if (typeof status === 'number' && Number.isFinite(status) && status > 0) {
    return String(status);
  }
  if (hasError) {
    return 'error';
  }
  return 'unknown';
}

function isTimeoutError(message) {
  if (!message) {
    return false;
  }
  return /timeout|timed out|ETIMEDOUT|ECONNRESET|socket hang up/i.test(message);
}

function percentile(sortedDurations, rank) {
  if (sortedDurations.length === 0) {
    return 0;
  }
  const index = Math.min(sortedDurations.length - 1, Math.max(0, Math.ceil((rank / 100) * sortedDurations.length) - 1));
  return sortedDurations[index];
}

function round(value) {
  return Math.round(value);
}

function formatBreakdown(breakdown) {
  const entries = Object.entries(breakdown ?? {}).sort(([left], [right]) => left.localeCompare(right));
  if (entries.length === 0) {
    return 'n/a';
  }
  return entries.map(([key, count]) => `${key}:${count}`).join(', ');
}

function escapeHtml(value) {
  return String(value)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

function parsePositiveInteger(raw) {
  if (!raw) {
    return undefined;
  }
  const value = Number.parseInt(raw, 10);
  if (!Number.isFinite(value) || value <= 0) {
    return undefined;
  }
  return value;
}

function findNodeApiCallFiles(rootDir) {
  const root = path.resolve(rootDir);
  const files = [];
  const pending = [{ dir: root, depth: 0 }];
  let scannedDirs = 0;

  while (pending.length > 0 && scannedDirs < NODE_API_SCAN_MAX_DIRS) {
    const current = pending.pop();
    if (!current) {
      continue;
    }

    let entries;
    try {
      entries = fs.readdirSync(current.dir, { withFileTypes: true });
    } catch {
      continue;
    }

    scannedDirs += 1;
    entries.forEach((entry) => {
      const fullPath = path.join(current.dir, entry.name);
      if (entry.isFile() && entry.name === 'node-api-calls.json') {
        files.push(fullPath);
        return;
      }
      if (!entry.isDirectory()) {
        return;
      }
      if (current.depth >= NODE_API_SCAN_MAX_DEPTH) {
        return;
      }
      if (NODE_API_SCAN_SKIP_DIRS.has(entry.name.toLowerCase())) {
        return;
      }
      pending.push({ dir: fullPath, depth: current.depth + 1 });
    });
  }

  if (pending.length > 0) {
    console.warn(
      `copy-odhin-report: node-api scan truncated for ${root} after ${scannedDirs} directories ` +
        `(maxDirs=${NODE_API_SCAN_MAX_DIRS}, maxDepth=${NODE_API_SCAN_MAX_DEPTH}).`
    );
  }
  return files;
}

function injectNodeApiTab(reportFolder, apiReport) {
  const files = fs.readdirSync(reportFolder).filter((f) => f.toLowerCase().endsWith('.html'));
  const tabView = buildNodeApiTabView(apiReport);
  const tabButton = buildNodeApiTabButton();
  const tabPane = buildNodeApiTabPane(apiReport, tabView);

  files.forEach((file) => {
    const fullPath = path.join(reportFolder, file);
    try {
      let html = fs.readFileSync(fullPath, 'utf8');
      html = injectNodeApiTabIntoHtml(html, tabButton, tabPane);
      fs.writeFileSync(fullPath, html, 'utf8');
    } catch {
      // ignore
    }
  });
}

function buildNodeApiTabView(apiReport) {
  const usingNodeApiAttachments = apiReport.dataSource === 'node-api-calls';
  return {
    dataSourceLabel: usingNodeApiAttachments ? 'node-api-calls.json attachments' : 'Odhin stdout/stderr runtime logs',
    sourceCountLabel: usingNodeApiAttachments ? 'node-api-calls.json files' : 'Odhin HTML files scanned',
    sourceCountValue: usingNodeApiAttachments ? apiReport.logFiles : apiReport.reportFilesScanned,
    totalCallsLabel: usingNodeApiAttachments ? 'Total API attempts' : 'Observed API warning/error events',
    sourceDescription: usingNodeApiAttachments
      ? 'Counts come from node-api-calls.json attachments captured during Playwright runs; percent is share of total calls.'
      : 'Counts come from Odhin stdout/stderr logs (DOWNSTREAM_API_FAILURE, Slow API response detected, and HTTP status lines). They represent observed warning/error events, not all successful calls.',
    endpointRows: buildNodeApiEndpointRows(apiReport, usingNodeApiAttachments),
    failedRows: buildNodeApiFailedRows(apiReport, usingNodeApiAttachments),
    slowRows: buildNodeApiSlowRows(apiReport, usingNodeApiAttachments),
  };
}

function buildNodeApiEndpointRows(apiReport, usingNodeApiAttachments) {
  if (!apiReport.endpoints.length) {
    return `<tr><td colspan="4" class="text-secondary-emphasis">${
      usingNodeApiAttachments
        ? apiReport.logFiles
          ? 'No API endpoints found in node-api-calls.json attachments.'
          : 'No node-api-calls.json attachments found.'
        : 'No API warning/error events found in Odhin runtime logs.'
    }</td></tr>`;
  }

  return apiReport.endpoints
    .map(({ method, endpoint, hits }) => {
      const pct = apiReport.totalCalls ? ((hits / apiReport.totalCalls) * 100).toFixed(2) : '0.00';
      return `<tr>
        <td class="text-secondary-emphasis">${escapeHtml(method)}</td>
        <td class="fs-6 text-secondary-emphasis text-start summary-row-left-column">${escapeHtml(endpoint)}</td>
        <td class="text-secondary-emphasis">${hits}</td>
        <td class="text-secondary-emphasis">${pct}%</td>
      </tr>`;
    })
    .join('\n');
}

function buildNodeApiFailedRows(apiReport, usingNodeApiAttachments) {
  if (!apiReport.failedEndpoints.length) {
    return [
      `<tr><td colspan="5" class="text-secondary-emphasis">${
        usingNodeApiAttachments
          ? 'No failed/timed-out API attempts captured in node-api-calls.json.'
          : 'No failed/timed-out API events captured in Odhin runtime logs.'
      }</td></tr>`,
    ];
  }

  return apiReport.failedEndpoints.slice(0, API_LEADERBOARD_LIMIT).map(({ method, endpoint, hits, timeoutHits, statusBreakdown }) => {
    return `<tr>
        <td class="text-secondary-emphasis">${escapeHtml(method)}</td>
        <td class="fs-6 text-secondary-emphasis text-start summary-row-left-column">${escapeHtml(endpoint)}</td>
        <td class="text-secondary-emphasis">${hits}</td>
        <td class="text-secondary-emphasis">${timeoutHits}</td>
        <td class="text-secondary-emphasis text-start">${escapeHtml(formatBreakdown(statusBreakdown))}</td>
      </tr>`;
  });
}

function buildNodeApiSlowRows(apiReport, usingNodeApiAttachments) {
  if (!apiReport.slowEndpoints.length) {
    return [
      `<tr><td colspan="7" class="text-secondary-emphasis">${
        usingNodeApiAttachments
          ? 'No slow API attempts above threshold captured in node-api-calls.json.'
          : 'No slow API events above threshold captured in Odhin runtime logs.'
      }</td></tr>`,
    ];
  }

  return apiReport.slowEndpoints
    .slice(0, API_LEADERBOARD_LIMIT)
    .map(({ method, endpoint, hits, avgDurationMs, p95DurationMs, maxDurationMs, statusBreakdown }) => {
      return `<tr>
        <td class="text-secondary-emphasis">${escapeHtml(method)}</td>
        <td class="fs-6 text-secondary-emphasis text-start summary-row-left-column">${escapeHtml(endpoint)}</td>
        <td class="text-secondary-emphasis">${hits}</td>
        <td class="text-secondary-emphasis">${avgDurationMs}</td>
        <td class="text-secondary-emphasis">${p95DurationMs}</td>
        <td class="text-secondary-emphasis">${maxDurationMs}</td>
        <td class="text-secondary-emphasis text-start">${escapeHtml(formatBreakdown(statusBreakdown))}</td>
      </tr>`;
    });
}

function buildNodeApiTabButton() {
  return `
<!-- NODE_API_TAB_BUTTON_START -->
            <button
              class="main-tablinks"
              onclick="openMainTab(event, 'TabNodeApi')"
            >
              Tested NodeJs API
            </button>
<!-- NODE_API_TAB_BUTTON_END -->`;
}

function buildNodeApiTabPane(apiReport, tabView) {
  return `
<!-- NODE_API_TAB_START -->
<div id="TabNodeApi" style="display: none" class="main-tabcontent">
  <div class="container-fluid text-center mt-3 mb-5">
    <div class="row ms-3 me-3">
      <div class="col-12">
        <div class="mt-3 mb-3 odhin-thin-border dashboard-block">
          <div class="info-box-header">Tested NodeJs API endpoints</div>
          <p class="text-secondary-emphasis small mb-3 ps-4">
            ${tabView.sourceDescription}
          </p>
          <p class="text-secondary-emphasis small mb-3 ps-4">
            Leaderboards include retries because each observed attempt is tracked independently.
          </p>
          <div class="odhin-table-no-scroll">
            <div class="table-responsive">
              <table class="table table-sm mb-0">
                <thead>
                  <tr>
                    <th class="odhin-text-3">Metric</th>
                    <th class="odhin-text-3">Value</th>
                  </tr>
                </thead>
                <tbody>
                  <tr><td class="text-secondary-emphasis text-start">Data source</td><td class="text-secondary-emphasis">${tabView.dataSourceLabel}</td></tr>
                  <tr><td class="text-secondary-emphasis text-start">${tabView.sourceCountLabel}</td><td class="text-secondary-emphasis">${tabView.sourceCountValue}</td></tr>
                  <tr><td class="text-secondary-emphasis text-start">${tabView.totalCallsLabel}</td><td class="text-secondary-emphasis">${apiReport.totalCalls}</td></tr>
                  <tr><td class="text-secondary-emphasis text-start">Unique method+endpoint pairs</td><td class="text-secondary-emphasis">${apiReport.uniqueEndpoints}</td></tr>
                  <tr><td class="text-secondary-emphasis text-start">Failed/timed-out attempts</td><td class="text-secondary-emphasis">${apiReport.totalFailedCalls} (timeout=${apiReport.totalTimeoutCalls})</td></tr>
                  <tr><td class="text-secondary-emphasis text-start">Slow attempts (&gt; ${apiReport.slowThresholdMs}ms)</td><td class="text-secondary-emphasis">${apiReport.totalSlowCalls}</td></tr>
                </tbody>
              </table>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class="row ms-3 me-3">
      <div class="col-12">
        <div class="mt-3 mb-3 odhin-thin-border dashboard-block">
          <div class="info-box-header">Endpoint inventory</div>
          <div class="odhin-table-no-scroll">
            <div class="table-responsive">
              <table class="table table-sm mb-0">
                <thead>
                  <tr>
                    <th class="odhin-text-3">Method</th>
                    <th class="odhin-text-3">Endpoint</th>
                    <th class="odhin-text-3">Calls</th>
                    <th class="odhin-text-3">Percent of calls</th>
                  </tr>
                </thead>
                <tbody>
                  ${tabView.endpointRows}
                </tbody>
              </table>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class="row ms-3 me-3">
      <div class="col-12">
        <div class="mt-3 mb-3 odhin-thin-border dashboard-block">
          <div class="info-box-header">Failed / timed-out API leaderboard</div>
          <p class="text-secondary-emphasis small mb-3 ps-4">
            Top ${API_LEADERBOARD_LIMIT} method+endpoint pairs by failed attempts.
          </p>
          <div class="odhin-table-no-scroll">
            <div class="table-responsive">
              <table class="table table-sm mb-0">
                <thead>
                  <tr>
                    <th class="odhin-text-3">Method</th>
                    <th class="odhin-text-3">Endpoint</th>
                    <th class="odhin-text-3">Failed attempts</th>
                    <th class="odhin-text-3">Timeout attempts</th>
                    <th class="odhin-text-3">Status breakdown</th>
                  </tr>
                </thead>
                <tbody>
                  ${tabView.failedRows.join('\n')}
                </tbody>
              </table>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class="row ms-3 me-3">
      <div class="col-12">
        <div class="mt-3 mb-3 odhin-thin-border dashboard-block">
          <div class="info-box-header">Slow API leaderboard</div>
          <p class="text-secondary-emphasis small mb-3 ps-4">
            Top ${API_LEADERBOARD_LIMIT} method+endpoint pairs where response time exceeded ${apiReport.slowThresholdMs}ms.
          </p>
          <div class="odhin-table-no-scroll">
            <div class="table-responsive">
              <table class="table table-sm mb-0">
                <thead>
                  <tr>
                    <th class="odhin-text-3">Method</th>
                    <th class="odhin-text-3">Endpoint</th>
                    <th class="odhin-text-3">Slow calls</th>
                    <th class="odhin-text-3">Avg (ms)</th>
                    <th class="odhin-text-3">P95 (ms)</th>
                    <th class="odhin-text-3">Max (ms)</th>
                    <th class="odhin-text-3">Status breakdown</th>
                  </tr>
                </thead>
                <tbody>
                  ${tabView.slowRows.join('\n')}
                </tbody>
              </table>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>
<!-- NODE_API_TAB_END -->`;
}

function injectNodeApiTabIntoHtml(html, tabButton, tabPane) {
  let updated = html;
  updated = updated.replace(/<!-- NODE_API_TAB_BUTTON_START -->[\s\S]*?<!-- NODE_API_TAB_BUTTON_END -->/g, '');
  updated = updated.replace(/<!-- NODE_API_TAB_START -->[\s\S]*?<!-- NODE_API_TAB_END -->/g, '');
  updated = updated.replace(/\s*<button[\s\S]*?openMainTab\(event,\s*'TabNodeApi'\)[\s\S]*?<\/button>/g, '');
  updated = removeNodeApiPane(updated);

  const tabBlock = /(<div class="tab">[\s\S]*?)(<\/div>\s*<\/div>\s*<\/div>\s*<\/div>)/m;
  if (tabBlock.test(updated)) {
    updated = updated.replace(tabBlock, `$1${tabButton}$2`);
  }

  return updated.replace('</body>', `${tabPane}\n</body>`);
}

function removeNodeApiPane(html) {
  let current = html;
  while (true) {
    const tabStart = current.indexOf('<div id="TabNodeApi"');
    if (tabStart === -1) {
      return current;
    }
    const tabEnd = findMatchingDivEnd(current, tabStart);
    if (tabEnd === -1) {
      return current;
    }
    current = `${current.slice(0, tabStart)}${current.slice(tabEnd)}`;
  }
}

function findMatchingDivEnd(html, startIndex) {
  const tagRegex = /<\/?div\b[^>]*>/gi;
  tagRegex.lastIndex = startIndex;

  let depth = 0;
  let seenFirstDiv = false;
  let match = tagRegex.exec(html);

  while (match) {
    const tag = match[0].toLowerCase();
    const isClosingTag = tag.startsWith('</div');
    if (!seenFirstDiv) {
      if (isClosingTag) {
        return -1;
      }
      seenFirstDiv = true;
    }

    if (isClosingTag) {
      depth -= 1;
      if (depth === 0) {
        return tagRegex.lastIndex;
      }
    } else {
      depth += 1;
    }

    match = tagRegex.exec(html);
  }

  return -1;
}
