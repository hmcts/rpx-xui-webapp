#!/usr/bin/env node
/**
 * Copies the Odhin report generated by Playwright into the legacy publish folder
 * so Jenkins can archive it. No-op if the report is missing.
 */
const fs = require('fs');
const path = require('path');

const source = path.resolve('functional-output', 'tests', 'playwright-api', 'odhin-report');
const targetRoot = path.resolve('functional-output', 'tests', 'api_functional');
const target = path.join(targetRoot, 'odhin-report');
const coverageRoot = path.resolve('reports', 'tests', 'coverage', 'api-playwright');
const coverageLinkFlag = process.env.PW_ODHIN_LINK_COVERAGE === 'true';
const LEGACY_ODHIN_REPORT_FILENAME = 'xui-playwright.html';
const API_ODHIN_REPORT_FILENAME = 'xui-playwright-api.html';

try {
  if (!fs.existsSync(source)) {
    process.exit(0);
  }

  fs.mkdirSync(targetRoot, { recursive: true });
  // Best-effort clean copy
  fs.rmSync(target, { recursive: true, force: true });
  fs.cpSync(source, target, { recursive: true, force: true });

  normalizeApiOdhinFilename(source);
  normalizeApiOdhinFilename(target);

  // Support both report publish locations (source and legacy copied target).
  const reportFolders = [source, target];
  const { endpoints, totalHits, logFiles } = collectApiEndpointsFromLogs(resolveNodeApiLogRoots());
  reportFolders.forEach((folder) => injectNodeApiTab(folder, endpoints, totalHits, logFiles));

  if (coverageLinkFlag && fs.existsSync(coverageRoot)) {
    reportFolders.forEach((folder) => {
      const coverageTarget = path.join(folder, 'coverage');
      fs.rmSync(coverageTarget, { recursive: true, force: true });
      fs.cpSync(coverageRoot, coverageTarget, { recursive: true, force: true });
      const coverageIndex = renameCoverageIndex(findCoverageIndex(coverageTarget));
      const coverageSummary = loadCoverageSummary(coverageTarget);
      if (coverageIndex) {
        injectCoverageLink(folder, path.relative(folder, coverageIndex), coverageSummary);
        injectCoverageTab(folder, path.relative(folder, coverageIndex));
      } else {
        console.warn(`copy-odhin-report: coverage index not found for ${folder}; skipping coverage block injection.`);
      }
    });
  }
} catch (error) {
  console.warn(`copy-odhin-report: ${error.message}`);
  process.exit(0); // do not fail the build if copy fails
}

function normalizeApiOdhinFilename(reportFolder) {
  const legacyFile = path.join(reportFolder, LEGACY_ODHIN_REPORT_FILENAME);
  const apiFile = path.join(reportFolder, API_ODHIN_REPORT_FILENAME);
  if (!fs.existsSync(legacyFile) || fs.existsSync(apiFile)) {
    return;
  }
  fs.renameSync(legacyFile, apiFile);
}

function findCoverageIndex(rootDir) {
  // Prefer the TS/API folder produced by c8 (`.../rpx-xui-webapp/playwright_tests_new/api/index.html`)
  const preferred = path.join(rootDir, 'rpx-xui-webapp', 'playwright_tests_new', 'api', 'index.html');
  if (fs.existsSync(preferred)) {
    return preferred;
  }
  const fallback = path.join(rootDir, 'index.html');
  return fs.existsSync(fallback) ? fallback : undefined;
}

function renameCoverageIndex(indexPath) {
  if (!indexPath) return undefined;
  const newPath = path.join(path.dirname(indexPath), 'api-coverage-report.html');
  try {
    fs.renameSync(indexPath, newPath);
    return newPath;
  } catch {
    return indexPath;
  }
}

function loadCoverageSummary(rootDir) {
  const summaryPath = path.join(rootDir, 'coverage-summary.json');
  if (!fs.existsSync(summaryPath)) {
    return undefined;
  }
  try {
    const json = JSON.parse(fs.readFileSync(summaryPath, 'utf8'));
    return json?.total;
  } catch (err) {
    console.warn(`copy-odhin-report: unable to parse coverage summary: ${err.message}`);
    return undefined;
  }
}

function injectCoverageLink(reportFolder, relativeCoveragePath, totals) {
  const files = fs.readdirSync(reportFolder).filter((f) => f.toLowerCase().endsWith('.html'));
  const rows = totals
    ? [
        ['Lines', totals.lines],
        ['Functions', totals.functions],
        ['Branches', totals.branches],
        ['Statements', totals.statements],
      ]
        .map(([label, data]) => {
          const pct = typeof data?.pct === 'number' ? data.pct.toFixed(2) : 'n/a';
          const covered = data?.covered ?? 0;
          const total = data?.total ?? 0;
          return `<tr>
      <td class="fs-6 text-secondary-emphasis text-start summary-row-left-column">${label}</td>
      <td class="text-secondary-emphasis">${pct}%</td>
      <td class="text-secondary-emphasis">${covered}</td>
      <td class="text-secondary-emphasis">${total}</td>
    </tr>`;
        })
        .join('\n')
    : '';

  const block = `
          <div class="row ms-3 me-3">
            <div class="col-12">
              <div class="mt-3 mb-3 odhin-thin-border dashboard-block">
                <div class="info-box-header">Coverage</div>
                <p class="text-secondary-emphasis small mb-2 ps-2">
                  Scope: totals from coverage-summary.json (all instrumented files in this run). Embedded HTML report may be folder-specific.
                </p>
                <div class="odhin-table">
                  <div class="table-responsive">
                    <table class="table table-sm mb-0 testcase-run-info-table">
                      <thead>
                        <tr>
                          <th class="odhin-text-3">Metric</th>
                          <th class="odhin-text-3">Percent</th>
                          <th class="odhin-text-3">Covered</th>
                          <th class="odhin-text-3">Total</th>
                        </tr>
                      </thead>
                      <tbody>
                        ${rows || '<tr><td colspan="4" class="text-secondary-emphasis">Summary unavailable</td></tr>'}
                      </tbody>
                    </table>
                  </div>
                </div>
              </div>
            </div>
          </div>`;
  files.forEach((file) => {
    const fullPath = path.join(reportFolder, file);
    try {
      let html = fs.readFileSync(fullPath, 'utf8');
      if (!html.includes('id="TabDashboard"')) {
        return;
      }
      // Remove any previously injected coverage block
      html = html.replace(
        /<div class="row ms-3 me-3">\s*<div class="col-12[^>]*>\s*<div class="mt-3 mb-3 odhin-thin-border dashboard-block">\s*<div class="info-box-header">Coverage[\s\S]*?<\/div>\s*<\/div>\s*<\/div>\s*<\/div>/m,
        ''
      );

      const tabDashPattern = /(<div[^>]+id="TabDashboard"[\s\S]*?)(<\/div>\s*<div[^>]+id="TabTests")/m;
      if (tabDashPattern.test(html)) {
        html = html.replace(tabDashPattern, (_m, before, after) => `${before}\n${block}\n</div>\n${after}`);
      }
      fs.writeFileSync(fullPath, html, 'utf8');
    } catch {
      // ignore
    }
  });
}

function injectCoverageTab(reportFolder, relativeCoveragePath) {
  const files = fs.readdirSync(reportFolder).filter((f) => f.toLowerCase().endsWith('.html'));
  const tabButton = `
							<button
								class="main-tablinks"
								onclick="openMainTab(event, 'TabCoverage')"
							>
								Coverage
							</button>`;
  const tabPane = `
<div id="TabCoverage" style="display: none" class="main-tabcontent">
  <div class="container-fluid text-center mt-3 mb-5">
    <div class="row ms-3 me-3">
      <div class="col-12">
        <div class="mt-3 mb-3 odhin-thin-border dashboard-block">
          <div class="info-box-header">Coverage report</div>
          <p class="text-secondary-emphasis small mb-3 ps-2">
            Source: ${relativeCoveragePath} (may be folder-specific).
          </p>
          <div class="odhin-table-no-scroll">
            <div class="table-responsive">
              <iframe src="${relativeCoveragePath}" style="width:100%;min-height:900px;border:0;"></iframe>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>`;

  files.forEach((file) => {
    const fullPath = path.join(reportFolder, file);
    try {
      let html = fs.readFileSync(fullPath, 'utf8');
      if (html.includes('id="TabCoverage"')) {
        return;
      }
      const tabBlock = /(<div class="tab">[\s\S]*?)(<\/div>\s*<\/div>\s*<\/div>\s*<\/div>)/m;
      if (tabBlock.test(html)) {
        html = html.replace(tabBlock, `$1${tabButton}$2`);
      }
      html = html.replace('</body>', `${tabPane}\n</body>`);
      fs.writeFileSync(fullPath, html, 'utf8');
    } catch {
      // ignore
    }
  });
}

function resolveNodeApiLogRoots() {
  const roots = new Set();
  const envRoots = [process.env.PW_NODE_API_LOG_ROOT, process.env.PLAYWRIGHT_OUTPUT_DIR, process.env.PLAYWRIGHT_TEST_OUTPUT_DIR];
  envRoots.filter(Boolean).forEach((root) => roots.add(path.resolve(root)));
  roots.add(path.resolve('test-results'));
  return Array.from(roots).filter((root) => fs.existsSync(root));
}

function collectApiEndpointsFromLogs(roots) {
  const counts = new Map();
  let logFiles = 0;

  roots.forEach((rootDir) => {
    if (!fs.existsSync(rootDir)) {
      return;
    }
    const files = walkFiles(rootDir).filter((file) => file.endsWith('node-api-calls.json'));
    files.forEach((file) => {
      logFiles += 1;
      try {
        const raw = fs.readFileSync(file, 'utf8');
        const entries = JSON.parse(raw);
        if (!Array.isArray(entries)) {
          return;
        }
        entries.forEach((entry) => {
          const endpoint = extractEndpointFromLog(entry);
          if (!endpoint) {
            return;
          }
          counts.set(endpoint, (counts.get(endpoint) ?? 0) + 1);
        });
      } catch {
        // ignore malformed attachments
      }
    });
  });

  const totalHits = Array.from(counts.values()).reduce((sum, n) => sum + n, 0);
  const endpoints = Array.from(counts.entries())
    .sort((a, b) => a[0].localeCompare(b[0]))
    .map(([endpoint, hits]) => ({ endpoint, hits }));
  return { endpoints, totalHits, logFiles };
}

function extractEndpointFromLog(entry) {
  const rawUrl = entry?.url;
  if (typeof rawUrl !== 'string' || !rawUrl) {
    return undefined;
  }
  let endpoint = rawUrl;
  if (/^https?:\/\//i.test(rawUrl)) {
    try {
      const parsed = new URL(rawUrl);
      endpoint = `${parsed.pathname}${parsed.search}`;
    } catch {
      endpoint = rawUrl;
    }
  }
  endpoint = endpoint.replace(/^\/+/, '');
  return normalizeEndpoint(endpoint);
}

function normalizeEndpoint(endpoint) {
  const uuidRe = /\b[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}\b/gi;
  const hexRe = /\b[0-9a-f]{32,}\b/gi;
  const caseIdRe = /\b\d{16}\b/g;
  const longNumberRe = /\b\d{6,}\b/g;
  return endpoint
    .replace(uuidRe, '${uuid}')
    .replace(hexRe, '${id}')
    .replace(caseIdRe, '${caseId}')
    .replace(longNumberRe, '${id}');
}

function walkFiles(dir) {
  const entries = fs.readdirSync(dir, { withFileTypes: true });
  let files = [];
  for (const entry of entries) {
    const full = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      files = files.concat(walkFiles(full));
    } else if (entry.isFile()) {
      files.push(full);
    }
  }
  return files;
}

function injectNodeApiTab(reportFolder, endpoints, totalHits, logFiles) {
  const files = fs.readdirSync(reportFolder).filter((f) => f.toLowerCase().endsWith('.html'));
  const rows = endpoints.length
    ? endpoints
        .map(({ endpoint, hits }) => {
          const pct = totalHits ? ((hits / totalHits) * 100).toFixed(2) : '0.00';
          return `<tr>
        <td class="fs-6 text-secondary-emphasis text-start summary-row-left-column">${endpoint}</td>
        <td class="text-secondary-emphasis">${hits}</td>
        <td class="text-secondary-emphasis">${pct}%</td>
      </tr>`;
        })
        .join('\n')
    : `<tr><td colspan="3" class="text-secondary-emphasis">${
        logFiles ? 'No API endpoints found in runtime logs' : 'No node-api-calls.json attachments found'
      }</td></tr>`;

  const tabButton = `
\t\t\t\t\t\t<button
\t\t\t\t\t\t\tclass="main-tablinks"
\t\t\t\t\t\t\tonclick="openMainTab(event, 'TabNodeApi')"
\t\t\t\t\t\t>
\t\t\t\t\t\t\tTested NodeJs API
\t\t\t\t\t\t</button>`;
  const tabPane = `
<div id="TabNodeApi" style="display: none" class="main-tabcontent">
  <div class="container-fluid text-center mt-3 mb-5">
    <div class="row ms-3 me-3">
      <div class="col-12">
        <div class="mt-3 mb-3 odhin-thin-border dashboard-block">
          <div class="info-box-header">Tested NodeJs API endpoints</div>
          <p class="text-secondary-emphasis small mb-3 ps-4">
            Counts come from node-api-calls.json attachments captured during Playwright runs; percent is share of total calls.
          </p>
          <p class="text-secondary-emphasis small mb-3 ps-4">
            This is an endpoint inventory, not server-side coverage. Use Mocha + c8 (yarn coverage:node) for Node coverage.
          </p>
          <div class="odhin-table-no-scroll">
            <div class="table-responsive">
              <table class="table table-sm mb-0">
                <thead>
                  <tr>
                    <th class="odhin-text-3">Endpoint</th>
                    <th class="odhin-text-3">Calls</th>
                    <th class="odhin-text-3">Percent of calls</th>
                  </tr>
                </thead>
                <tbody>
                  ${rows}
                </tbody>
              </table>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>`;

  files.forEach((file) => {
    const fullPath = path.join(reportFolder, file);
    try {
      let html = fs.readFileSync(fullPath, 'utf8');
      if (html.includes('id="TabNodeApi"')) {
        return;
      }
      const tabBlock = /(<div class="tab">[\s\S]*?)(<\/div>\s*<\/div>\s*<\/div>\s*<\/div>)/m;
      if (tabBlock.test(html)) {
        html = html.replace(tabBlock, `$1${tabButton}$2`);
      }
      html = html.replace('</body>', `${tabPane}\n</body>`);
      fs.writeFileSync(fullPath, html, 'utf8');
    } catch {
      // ignore
    }
  });
}
