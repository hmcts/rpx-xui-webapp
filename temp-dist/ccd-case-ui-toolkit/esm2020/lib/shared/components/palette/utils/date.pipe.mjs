import { Pipe } from '@angular/core';
import * as moment from 'moment';
import { FormatTranslatorService } from '../../../services/case-fields/format-translator.service';
import * as i0 from "@angular/core";
import * as i1 from "../../../services/case-fields/format-translator.service";
export class DatePipe {
    /**
     * constructor to allow format translator to be injected
     * @param formatTrans format translator
     */
    constructor(formatTrans) {
        this.formatTrans = formatTrans;
    }
    transform(value, zone, format) {
        let resultDate = null;
        const ISO_FORMAT = 'YYYY-MM-DDTHH:mm:ss.SSSZ';
        if (value) {
            // included to avoid editing the hour twice on second pass through
            // this occurs on case details when datepipe is applied twice
            if (!value.includes('T')) {
                zone = 'utc';
            }
            const match = value.match(DatePipe.DATE_FORMAT_REGEXP);
            // Make sure we actually have a match.
            if (match) {
                let offsetDate = null;
                const date = this.getDate(match);
                if (zone === 'local') {
                    offsetDate = this.getOffsetDate(date);
                }
                else {
                    offsetDate = this.getDate(match);
                }
                // 'short' format is meaningful to formatDate, but not the same meaning as in the unit tests
                if (this.formatTrans && format && format !== 'short') {
                    // support for java style formatting strings for dates
                    format = this.translateDateFormat(format);
                    resultDate = moment(date).format(format);
                }
                else {
                    // RDM-1149 changed the pipe logic so that it doesn't add an hour to 'Summer Time' dates on DateTime field type
                    resultDate = `${offsetDate.getDate()} ${DatePipe.MONTHS[offsetDate.getMonth()]} ${offsetDate.getFullYear()}`;
                    if (match[4] && match[5] && match[6] && format !== 'short') {
                        resultDate += ', ';
                        resultDate += `${this.getHour(offsetDate.getHours().toString())}:`;
                        resultDate += `${this.pad(offsetDate.getMinutes())}:`;
                        resultDate += `${this.pad(offsetDate.getSeconds())} `;
                        resultDate += (this.toInt(offsetDate.getHours().toString()) >= 12) ? 'PM' : 'AM';
                    }
                }
            }
            else {
                // EUI-2667. See if what we've been given is actually a formatted date that
                // we could attempt to do something with.
                const parsedDate = Date.parse(value);
                // We successfully parsed it so let's use it.
                if (!isNaN(parsedDate)) {
                    const d = new Date(parsedDate);
                    // If what we received didn't include time, don't include it here either.
                    if (value.indexOf(':') < 0) {
                        const shortDate = d.toLocaleDateString('en-GB');
                        const shortISO = shortDate.split('/').reverse().join('-');
                        return this.transform(shortISO, zone, format);
                    }
                    // If it did include time, we want a full ISO string.
                    const thisMoment = moment(d).format(ISO_FORMAT);
                    return this.transform(thisMoment, zone, format);
                }
            }
        }
        return resultDate;
    }
    translateDateFormat(format) {
        if (this.formatTrans) {
            return this.formatTrans.translate(format);
        }
        else {
            return format;
        }
    }
    getOffsetDate(date) {
        const localOffset = -date.getTimezoneOffset() / 60;
        return new Date(date.getTime() + localOffset * 3600 * 1000);
    }
    getDate(match) {
        const year = this.toInt(match[1]);
        const month = this.toInt(match[2]) - 1;
        const day = this.toInt(match[3]);
        let resultDate;
        if (match[4] && match[5] && match[6]) {
            const hour = this.toInt(match[4]);
            const minutes = this.toInt(match[5]);
            const seconds = this.toInt(match[6]);
            resultDate = new Date(year, month, day, hour, minutes, seconds, 0);
        }
        else {
            resultDate = new Date(year, month, day);
        }
        return resultDate;
    }
    getHour(hourStr) {
        let hourNum = this.toInt(hourStr);
        if (hourNum > 12) {
            hourNum = hourNum - 12;
        }
        else if (hourNum === 0) {
            hourNum = 12;
        }
        return hourNum;
    }
    toInt(str) {
        return parseInt(str, 10);
    }
    pad(num, padNum = 2) {
        const val = num !== undefined ? num.toString() : '';
        return val.length >= padNum ? val : new Array(padNum - val.length + 1).join('0') + val;
    }
}
DatePipe.DATE_FORMAT_REGEXP = new RegExp('^(\\d{4})-?(\\d\\d)-?(\\d\\d)(?:T(\\d\\d)(?::?(\\d\\d)(?::?(\\d\\d)(?:\\.(\\d+))?)?)?(Z|([+-])(\\d\\d):?(\\d\\d))?|Z)?$');
//    1        2       3         4          5          6          7          8  9     10      11
DatePipe.MONTHS = [
    ['Jan'], ['Feb'], ['Mar'], ['Apr'], ['May'], ['Jun'], ['Jul'], ['Aug'], ['Sep'], ['Oct'], ['Nov'], ['Dec'],
];
DatePipe.ɵfac = function DatePipe_Factory(t) { return new (t || DatePipe)(i0.ɵɵdirectiveInject(i1.FormatTranslatorService, 16)); };
DatePipe.ɵpipe = /*@__PURE__*/ i0.ɵɵdefinePipe({ name: "ccdDate", type: DatePipe, pure: true });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(DatePipe, [{
        type: Pipe,
        args: [{
                name: 'ccdDate'
            }]
    }], function () { return [{ type: i1.FormatTranslatorService }]; }, null); })();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZS5waXBlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvY2NkLWNhc2UtdWktdG9vbGtpdC9zcmMvbGliL3NoYXJlZC9jb21wb25lbnRzL3BhbGV0dGUvdXRpbHMvZGF0ZS5waXBlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxJQUFJLEVBQWlCLE1BQU0sZUFBZSxDQUFDO0FBQ3BELE9BQU8sS0FBSyxNQUFNLE1BQU0sUUFBUSxDQUFDO0FBRWpDLE9BQU8sRUFBRSx1QkFBdUIsRUFBRSxNQUFNLHlEQUF5RCxDQUFDOzs7QUFLbEcsTUFBTSxPQUFPLFFBQVE7SUFRbkI7OztPQUdHO0lBQ0gsWUFBNkIsV0FBb0M7UUFBcEMsZ0JBQVcsR0FBWCxXQUFXLENBQXlCO0lBQ2pFLENBQUM7SUFFTSxTQUFTLENBQUMsS0FBYSxFQUFFLElBQWEsRUFBRSxNQUFlO1FBQzVELElBQUksVUFBVSxHQUFHLElBQUksQ0FBQztRQUN0QixNQUFNLFVBQVUsR0FBRywwQkFBMEIsQ0FBQztRQUM5QyxJQUFJLEtBQUssRUFBRTtZQUNULGtFQUFrRTtZQUNsRSw2REFBNkQ7WUFDN0QsSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLEVBQUU7Z0JBQ3hCLElBQUksR0FBRyxLQUFLLENBQUM7YUFDZDtZQUNELE1BQU0sS0FBSyxHQUFxQixLQUFLLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO1lBQ3pFLHNDQUFzQztZQUN0QyxJQUFJLEtBQUssRUFBRTtnQkFDVCxJQUFJLFVBQVUsR0FBRyxJQUFJLENBQUM7Z0JBQ3RCLE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7Z0JBQ2pDLElBQUksSUFBSSxLQUFLLE9BQU8sRUFBRTtvQkFDcEIsVUFBVSxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMs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QUFFLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUM7Q0FDM0csQ0FBQztnRUFOUyxRQUFRO3dFQUFSLFFBQVE7dUZBQVIsUUFBUTtjQUhwQixJQUFJO2VBQUM7Z0JBQ0osSUFBSSxFQUFFLFNBQVM7YUFDaEIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQaXBlLCBQaXBlVHJhbnNmb3JtIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgKiBhcyBtb21lbnQgZnJvbSAnbW9tZW50JztcblxuaW1wb3J0IHsgRm9ybWF0VHJhbnNsYXRvclNlcnZpY2UgfSBmcm9tICcuLi8uLi8uLi9zZXJ2aWNlcy9jYXNlLWZpZWxkcy9mb3JtYXQtdHJhbnNsYXRvci5zZXJ2aWNlJztcblxuQFBpcGUoe1xuICBuYW1lOiAnY2NkRGF0ZSdcbn0pXG5leHBvcnQgY2xhc3MgRGF0ZVBpcGUgaW1wbGVtZW50cyBQaXBlVHJhbnNmb3JtIHtcbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgREFURV9GT1JNQVRfUkVHRVhQID1cbiAgICBuZXcgUmVnRXhwKCdeKFxcXFxkezR9KS0/KFxcXFxkXFxcXGQpLT8oXFxcXGRcXFxcZCkoPzpUKFxcXFxkXFxcXGQpKD86Oj8oXFxcXGRcXFxcZCkoPzo6PyhcXFxcZFxcXFxkKSg/OlxcXFwuKFxcXFxkKykpPyk/KT8oWnwoWystXSkoXFxcXGRcXFxcZCk6PyhcXFxcZFxcXFxkKSk/fFopPyQnKTtcbiAgICAgICAgICAgLy8gICAgMSAgICAgICAgMiAgICAgICAzICAgICAgICAgNCAgICAgICAgICA1ICAgICAgICAgIDYgICAgICAgICAgNyAgICAgICAgICA4ICA5ICAgICAxMCAgICAgIDExXG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IE1PTlRIUyA9IFtcbiAgICBbJ0phbiddLCBbJ0ZlYiddLCBbJ01hciddLCBbJ0FwciddLCBbJ01heSddLCBbJ0p1biddLCBbJ0p1bCddLCBbJ0F1ZyddLCBbJ1NlcCddLCBbJ09jdCddLCBbJ05vdiddLCBbJ0RlYyddLFxuICBdO1xuXG4gIC8qKlxuICAgKiBjb25zdHJ1Y3RvciB0byBhbGxvdyBmb3JtYXQgdHJhbnNsYXRvciB0byBiZSBpbmplY3RlZFxuICAgKiBAcGFyYW0gZm9ybWF0VHJhbnMgZm9ybWF0IHRyYW5zbGF0b3JcbiAgICovXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgZm9ybWF0VHJhbnM6IEZvcm1hdFRyYW5zbGF0b3JTZXJ2aWNlKSB7XG4gIH1cblxuICBwdWJsaWMgdHJhbnNmb3JtKHZhbHVlOiBzdHJpbmcsIHpvbmU/OiBzdHJpbmcsIGZvcm1hdD86IHN0cmluZyk6IHN0cmluZyB7XG4gICAgbGV0IHJlc3VsdERhdGUgPSBudWxsO1xuICAgIGNvbnN0IElTT19GT1JNQVQgPSAnWVlZWS1NTS1ERFRISDptbTpzcy5TU1NaJztcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIC8vIGluY2x1ZGVkIHRvIGF2b2lkIGVkaXRpbmcgdGhlIGhvdXIgdHdpY2Ugb24gc2Vjb25kIHBhc3MgdGhyb3VnaFxuICAgICAgLy8gdGhpcyBvY2N1cnMgb24gY2FzZSBkZXRhaWxzIHdoZW4gZGF0ZXBpcGUgaXMgYXBwbGllZCB0d2ljZVxuICAgICAgaWYgKCF2YWx1ZS5pbmNsdWRlcygnVCcpKSB7XG4gICAgICAgIHpvbmUgPSAndXRjJztcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1hdGNoOiBSZWdFeHBNYXRjaEFycmF5ID0gdmFsdWUubWF0Y2goRGF0ZVBpcGUuREFURV9GT1JNQVRfUkVHRVhQKTtcbiAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBhY3R1YWxseSBoYXZlIGEgbWF0Y2guXG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgbGV0IG9mZnNldERhdGUgPSBudWxsO1xuICAgICAgICBjb25zdCBkYXRlID0gdGhpcy5nZXREYXRlKG1hdGNoKTtcbiAgICAgICAgaWYgKHpvbmUgPT09ICdsb2NhbCcpIHtcbiAgICAgICAgICBvZmZzZXREYXRlID0gdGhpcy5nZXRPZmZzZXREYXRlKGRhdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9mZnNldERhdGUgPSB0aGlzLmdldERhdGUobWF0Y2gpO1xuICAgICAgICB9XG4gICAgICAgIC8vICdzaG9ydCcgZm9ybWF0IGlzIG1lYW5pbmdmdWwgdG8gZm9ybWF0RGF0ZSwgYnV0IG5vdCB0aGUgc2FtZSBtZWFuaW5nIGFzIGluIHRoZSB1bml0IHRlc3RzXG4gICAgICAgIGlmICh0aGlzLmZvcm1hdFRyYW5zICYmIGZvcm1hdCAmJiBmb3JtYXQgIT09ICdzaG9ydCcpIHtcbiAgICAgICAgICAvLyBzdXBwb3J0IGZvciBqYXZhIHN0eWxlIGZvcm1hdHRpbmcgc3RyaW5ncyBmb3IgZGF0ZXNcbiAgICAgICAgICBmb3JtYXQgPSB0aGlzLnRyYW5zbGF0ZURhdGVGb3JtYXQoZm9ybWF0KTtcbiAgICAgICAgICByZXN1bHREYXRlID0gbW9tZW50KGRhdGUpLmZvcm1hdChmb3JtYXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFJETS0xMTQ5IGNoYW5nZWQgdGhlIHBpcGUgbG9naWMgc28gdGhhdCBpdCBkb2Vzbid0IGFkZCBhbiBob3VyIHRvICdTdW1tZXIgVGltZScgZGF0ZXMgb24gRGF0ZVRpbWUgZmllbGQgdHlwZVxuICAgICAgICAgIHJlc3VsdERhdGUgPSBgJHtvZmZzZXREYXRlLmdldERhdGUoKX0gJHtEYXRlUGlwZS5NT05USFNbb2Zmc2V0RGF0ZS5nZXRNb250aCgpXX0gJHtvZmZzZXREYXRlLmdldEZ1bGxZZWFyKCl9YDtcbiAgICAgICAgICBpZiAobWF0Y2hbNF0gJiYgbWF0Y2hbNV0gJiYgbWF0Y2hbNl0gJiYgZm9ybWF0ICE9PSAnc2hvcnQnKSB7XG4gICAgICAgICAgICByZXN1bHREYXRlICs9ICcsICc7XG4gICAgICAgICAgICByZXN1bHREYXRlICs9IGAke3RoaXMuZ2V0SG91cihvZmZzZXREYXRlLmdldEhvdXJzKCkudG9TdHJpbmcoKSl9OmA7XG4gICAgICAgICAgICByZXN1bHREYXRlICs9IGAke3RoaXMucGFkKG9mZnNldERhdGUuZ2V0TWludXRlcygpKX06YDtcbiAgICAgICAgICAgIHJlc3VsdERhdGUgKz0gYCR7dGhpcy5wYWQob2Zmc2V0RGF0ZS5nZXRTZWNvbmRzKCkpfSBgO1xuICAgICAgICAgICAgcmVzdWx0RGF0ZSArPSAodGhpcy50b0ludChvZmZzZXREYXRlLmdldEhvdXJzKCkudG9TdHJpbmcoKSkgPj0gMTIpID8gJ1BNJyA6ICdBTSc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBFVUktMjY2Ny4gU2VlIGlmIHdoYXQgd2UndmUgYmVlbiBnaXZlbiBpcyBhY3R1YWxseSBhIGZvcm1hdHRlZCBkYXRlIHRoYXRcbiAgICAgICAgLy8gd2UgY291bGQgYXR0ZW1wdCB0byBkbyBzb21ldGhpbmcgd2l0aC5cbiAgICAgICAgY29uc3QgcGFyc2VkRGF0ZTogbnVtYmVyID0gRGF0ZS5wYXJzZSh2YWx1ZSk7XG4gICAgICAgIC8vIFdlIHN1Y2Nlc3NmdWxseSBwYXJzZWQgaXQgc28gbGV0J3MgdXNlIGl0LlxuICAgICAgICBpZiAoIWlzTmFOKHBhcnNlZERhdGUpKSB7XG4gICAgICAgICAgY29uc3QgZDogRGF0ZSA9IG5ldyBEYXRlKHBhcnNlZERhdGUpO1xuICAgICAgICAgIC8vIElmIHdoYXQgd2UgcmVjZWl2ZWQgZGlkbid0IGluY2x1ZGUgdGltZSwgZG9uJ3QgaW5jbHVkZSBpdCBoZXJlIGVpdGhlci5cbiAgICAgICAgICBpZiAodmFsdWUuaW5kZXhPZignOicpIDwgMCkge1xuICAgICAgICAgICAgY29uc3Qgc2hvcnREYXRlOiBzdHJpbmcgPSBkLnRvTG9jYWxlRGF0ZVN0cmluZygnZW4tR0InKTtcbiAgICAgICAgICAgIGNvbnN0IHNob3J0SVNPOiBzdHJpbmcgPSBzaG9ydERhdGUuc3BsaXQoJy8nKS5yZXZlcnNlKCkuam9pbignLScpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKHNob3J0SVNPLCB6b25lLCBmb3JtYXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBJZiBpdCBkaWQgaW5jbHVkZSB0aW1lLCB3ZSB3YW50IGEgZnVsbCBJU08gc3RyaW5nLlxuICAgICAgICAgIGNvbnN0IHRoaXNNb21lbnQgPSBtb21lbnQoZCkuZm9ybWF0KElTT19GT1JNQVQpO1xuICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybSh0aGlzTW9tZW50LCB6b25lLCBmb3JtYXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHREYXRlO1xuICB9XG5cbiAgcHJpdmF0ZSB0cmFuc2xhdGVEYXRlRm9ybWF0KGZvcm1hdDogc3RyaW5nKSB7XG4gICAgaWYgKHRoaXMuZm9ybWF0VHJhbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLmZvcm1hdFRyYW5zLnRyYW5zbGF0ZShmb3JtYXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZm9ybWF0O1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZ2V0T2Zmc2V0RGF0ZShkYXRlOiBEYXRlKTogRGF0ZSB7XG4gICAgY29uc3QgbG9jYWxPZmZzZXQgPSAtIGRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKSAvIDYwO1xuICAgIHJldHVybiBuZXcgRGF0ZShkYXRlLmdldFRpbWUoKSArIGxvY2FsT2Zmc2V0ICogMzYwMCAqIDEwMDApO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXREYXRlKG1hdGNoOiBSZWdFeHBNYXRjaEFycmF5KTogRGF0ZSB7XG4gICAgY29uc3QgeWVhciA9IHRoaXMudG9JbnQobWF0Y2hbMV0pO1xuICAgIGNvbnN0IG1vbnRoID0gdGhpcy50b0ludChtYXRjaFsyXSkgLSAxO1xuICAgIGNvbnN0IGRheSA9IHRoaXMudG9JbnQobWF0Y2hbM10pO1xuICAgIGxldCByZXN1bHREYXRlO1xuICAgIGlmIChtYXRjaFs0XSAmJiBtYXRjaFs1XSAmJiBtYXRjaFs2XSkge1xuICAgICAgY29uc3QgaG91ciA9IHRoaXMudG9JbnQobWF0Y2hbNF0pO1xuICAgICAgY29uc3QgbWludXRlcyA9IHRoaXMudG9JbnQobWF0Y2hbNV0pO1xuICAgICAgY29uc3Qgc2Vjb25kcyA9IHRoaXMudG9JbnQobWF0Y2hbNl0pO1xuICAgICAgcmVzdWx0RGF0ZSA9IG5ldyBEYXRlKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZXMsIHNlY29uZHMsIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHREYXRlID0gbmV3IERhdGUoeWVhciwgbW9udGgsIGRheSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHREYXRlO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRIb3VyKGhvdXJTdHI6IHN0cmluZyk6IG51bWJlciB7XG4gICAgbGV0IGhvdXJOdW0gPSB0aGlzLnRvSW50KGhvdXJTdHIpO1xuICAgIGlmIChob3VyTnVtID4gMTIpIHtcbiAgICAgIGhvdXJOdW0gPSBob3VyTnVtIC0gMTI7XG4gICAgfSBlbHNlIGlmIChob3VyTnVtID09PSAwKSB7XG4gICAgICBob3VyTnVtID0gMTI7XG4gICAgfVxuICAgIHJldHVybiBob3VyTnVtO1xuICB9XG5cbiAgcHJpdmF0ZSB0b0ludChzdHI6IHN0cmluZyk6IG51bWJlciB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHN0ciwgMTApO1xuICB9XG5cbiAgcHJpdmF0ZSBwYWQobnVtOiBhbnksIHBhZE51bSA9IDIpOiBzdHJpbmcge1xuICAgIGNvbnN0IHZhbCA9IG51bSAhPT0gdW5kZWZpbmVkID8gbnVtLnRvU3RyaW5nKCkgOiAnJztcbiAgICByZXR1cm4gdmFsLmxlbmd0aCA+PSBwYWROdW0gPyB2YWwgOiBuZXcgQXJyYXkocGFkTnVtIC0gdmFsLmxlbmd0aCArIDEpLmpvaW4oJzAnKSArIHZhbDtcbiAgfVxufVxuIl19